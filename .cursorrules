# BYD-HASS Go Application - Cursor Rules

## Project Overview
This is a Go static binary application designed to run on Android 10 via Termux. The application polls a local HTTP API (Diplus), caches results, and transmits data via MQTT or to ABRP (A Better Route Planner).

## Architecture & Design Principles

### Core Components
- **HTTP Client**: Polls Diplus API at `http://localhost:8988/api/getDiPars`
- **Cache System**: Stores sensor values to avoid redundant transmissions
- **Transmission Layer**: Supports both MQTT and HTTP (ABRP) endpoints with different intervals
- **Configuration**: Command-line arguments and environment variables for configuration
- **Logging**: Structured logging with different verbosity levels

### Timing Requirements
- **Diplus API Polling**: Every 15 seconds to get latest sensor data
- **ABRP Transmission**: Every 10 seconds (only if values changed)
- **MQTT Transmission**: Every 60 seconds (only if values changed)
- **Change Detection**: Use caching to avoid redundant transmissions

### Key Design Requirements
- **Static Binary**: Must compile to a single executable for Android ARM64
- **Resource Efficient**: Minimal memory and CPU usage for embedded environment
- **Fault Tolerant**: Graceful handling of network failures and API errors
- **Configurable**: Easy configuration without recompilation
- **Cross-Platform Build**: Support for building on Linux/Windows for Android target
- **Separate Transmission Schedules**: Different intervals for different endpoints

## Go Code Standards

### Project Structure
```
cmd/
  byd-hass/
    main.go          # Application entry point with multiple tickers
internal/
  api/
    diplus.go        # Diplus API client
    abrp.go          # ABRP API client
  cache/
    cache.go         # Caching layer for change detection
  config/
    config.go        # Configuration management
  mqtt/
    client.go        # MQTT client
  sensors/
    types.go         # Sensor data structures
    parser.go        # Data parsing logic
  transmission/
    transmitter.go   # Transmission interface
    mqtt.go          # MQTT transmitter
    abrp.go          # ABRP transmitter
build/
  build.sh           # Build script for cross-compilation
```

### Code Style & Patterns
- **Error Handling**: Use `errors.Wrap()` for context, return errors up the stack
- **HTTP Client**: Use `http.Client` with timeouts and retry logic
- **Logging**: Use structured logging with `logrus` or `zap` - but keep logging to a minimal and make use of an optional command argument verbose to expose whats going on
- **Testing**: No need for unit tests.
- **Dependencies**: Minimize external dependencies, prefer standard library
- **Timing**: Use separate time.Ticker instances for different polling/transmission intervals

### Key Dependencies
```go
// Core dependencies
github.com/sirupsen/logrus      // Logging
github.com/eclipse/paho.mqtt.golang  // MQTT client with WebSocket support
encoding/json                   // JSON handling for MQTT payloads

// Optional for enhanced features
github.com/robfig/cron/v3       // Scheduled polling
github.com/hashicorp/go-retryablehttp  // Retry logic
```

## Configuration Management

### Configuration Files
We will have no configuration files, instead sane defaults with overrides per command line arguments.

### Command Line Arguments
```bash
byd-hass [options]

Options:
  -mqtt-url string          MQTT WebSocket URL (ws://user:pass@host:port/path)
  -abrp-api-key string      ABRP API key for telemetry
  -abrp-vehicle-key string  ABRP vehicle identifier key
  -device-id string         Unique device identifier (default: auto-generated)
  -verbose                  Enable verbose logging
  -discovery-prefix string  Home Assistant discovery prefix (default: homeassistant)
```

### Environment Variables
Support for environment variable overrides:
- `BYD_HASS_MQTT_URL` - MQTT WebSocket URL including credentials
- `BYD_HASS_ABRP_API_KEY` - API key for ABRP
- `BYD_HASS_ABRP_VEHICLE_KEY` - Key identifying the car
- `BYD_HASS_DEVICE_ID` - Unique device identifier
- `BYD_HASS_VERBOSE` - Enable verbose logging (true/false)

### Fixed Intervals
- **Diplus Polling**: 15 seconds (fixed, not configurable)
- **ABRP Transmission**: 10 seconds (fixed, not configurable)
- **MQTT Transmission**: 60 seconds (fixed, not configurable)

## MQTT Integration

### MQTT WebSocket Client
- **WebSocket Transport**: Use `ws://` or `wss://` URLs for MQTT over WebSocket
- **Connection String**: Support URLs like `ws://mqtt-broker:9001/mqtt` or `wss://mqtt-broker:8084/mqtt`
- **Authentication**: Include credentials in URL or via client options
- **Auto-Reconnect**: Implement reconnection logic with exponential backoff

### Home Assistant MQTT Discovery
- **Discovery Prefix**: Default to `homeassistant` (configurable)
- **Device Registry**: Register BYD car as a single device with multiple entities
- **Entity Categories**: Use appropriate categories (diagnostic, sensor, etc.)
- **Unique IDs**: Generate consistent unique IDs for entities
- **Device Class**: Use appropriate device classes (battery, distance, speed, etc.)

```go
type HADiscoveryConfig struct {
    Name               string `json:"name"`
    UniqueID           string `json:"unique_id"`
    StateTopic         string `json:"state_topic"`
    DeviceClass        string `json:"device_class,omitempty"`
    UnitOfMeasurement  string `json:"unit_of_measurement,omitempty"`
    Device             HADevice `json:"device"`
}

type HADevice struct {
    Identifiers  []string `json:"identifiers"`
    Name         string   `json:"name"`
    Model        string   `json:"model"`
    Manufacturer string   `json:"manufacturer"`
    SWVersion    string   `json:"sw_version,omitempty"`
}
```

### MQTT Topics Structure
```
# Sensor Discovery (Read-only)
homeassistant/sensor/byd_car_[device_id]/soc/config          # Discovery config
homeassistant/sensor/byd_car_[device_id]/mileage/config      # Discovery config
homeassistant/sensor/byd_car_[device_id]/speed/config        # Discovery config
homeassistant/binary_sensor/byd_car_[device_id]/lock/config  # Discovery config
homeassistant/binary_sensor/byd_car_[device_id]/charging/config # Discovery config

# Control Entity Discovery (Future - Bidirectional)
homeassistant/climate/byd_car_[device_id]/hvac/config        # Climate control
homeassistant/lock/byd_car_[device_id]/doors/config          # Door lock/unlock
homeassistant/switch/byd_car_[device_id]/engine/config       # Start/stop engine
homeassistant/switch/byd_car_[device_id]/charging/config     # Start/stop charging

# State Topics (Publish sensor data)
byd_car/[device_id]/state                                    # All sensor states (JSON)
byd_car/[device_id]/availability                             # Online/offline status

# Command Topics (Subscribe for control - Future)
byd_car/[device_id]/climate/set                              # Climate control commands
byd_car/[device_id]/lock/set                                 # Lock/unlock commands
byd_car/[device_id]/engine/set                               # Engine start/stop
byd_car/[device_id]/charging/set                             # Charging control
```

## API Integration

### Diplus API Client
```go
type DiplusClient struct {
    baseURL    string
    httpClient *http.Client
    logger     *logrus.Logger
}

type SensorData struct {
    SOC            float64 `json:"soc"`
    Mileage        float64 `json:"mileage"`
    LockState      int     `json:"lock"`
    ChargeGunState int     `json:"charge_gun_state"`
    Speed          float64 `json:"speed"`
    Timestamp      time.Time
}

// Future: Command API interface
type CommandAPI interface {
    SetClimate(temp float64, mode string, fanSpeed int) error
    SetLock(action string) error  // "lock" or "unlock"
    SetEngine(action string) error // "start" or "stop"
    SetCharging(action string) error // "start" or "stop"
}

// Future: Diplus command client (if API supports it)
type DiplusCommandClient struct {
    baseURL    string
    httpClient *http.Client
    logger     *logrus.Logger
}
```

### Transmission Interfaces
```go
type Transmitter interface {
    Transmit(data *SensorData) error
    IsConnected() bool
}

type MQTTTransmitter struct {
    client mqtt.Client
    baseTopic string
    deviceID  string
    // Home Assistant MQTT Discovery
    discoveryPrefix string
    // Command handling (Future)
    commandHandlers map[string]CommandHandler
}

// Future: Command handling interface
type CommandHandler interface {
    HandleCommand(topic string, payload []byte) error
}

type ClimateCommand struct {
    Temperature float64 `json:"temperature"`
    Mode        string  `json:"mode"`
    FanSpeed    int     `json:"fan_speed"`
}

type LockCommand struct {
    Action string `json:"action"` // "lock" or "unlock"
}

type EngineCommand struct {
    Action string `json:"action"` // "start" or "stop"
}

type ABRPTransmitter struct {
    apiKey     string
    vehicleKey string
    httpClient *http.Client
}
```

## Caching Strategy

### Cache Implementation
- **Memory-based**: Simple key-value storage in JSON format
- **TTL Support**: Configurable cache expiration
- **Change Detection**: Only transmit when values change
- **Not Persistent**: Fetch data when the application starts, and cache that and renew on TTL 

### Cache Structure
```go
type CacheEntry struct {
    Value     interface{} `json:"value"`
    Timestamp time.Time   `json:"timestamp"`
    TTL       time.Duration `json:"ttl"`
}
```

## Error Handling & Resilience

### Retry Logic
- **Exponential Backoff**: For network failures
- **Circuit Breaker**: Prevent cascading failures
- **Graceful Degradation**: Continue operation with cached data

## Build & Deployment

### Cross-Compilation
```bash
# Build for Android ARM64
GOOS=linux GOARCH=arm64 CGO_ENABLED=0 go build -ldflags="-s -w" -o byd-hass cmd/byd-hass/main.go
```

### Docker Build
- Multi-stage build for minimal binary size
- Alpine Linux base for compatibility
- ARM64 target support

### Installation Script
- Replace shell scripts with Go binary
- Maintain Termux:Boot integration

## Performance Considerations

### Resource Usage
- **Memory**: Target <50MB resident memory
- **CPU**: Minimal background processing
- **Network**: Efficient polling with change detection

### Optimization
- **Connection Pooling**: Reuse HTTP connections
- **Separate Transmission Schedules**: Different intervals for different endpoints
- **Compression**: Gzip for large payloads
- **Caching**: Aggressive caching to reduce API calls

## Security Considerations

### Configuration Security
- **Sensitive Data**: Encrypt tokens in config files
- **File Permissions**: Restrict config file access
- **Environment Variables**: Secure credential injection

### Network Security
- **TLS**: Enforce HTTPS for all external APIs
- **Certificate Validation**: Proper CA verification
- **Token Rotation**: Support for credential refresh

## Monitoring & Observability

### Logging
- **Structured Logs**: JSON format for parsing

## Migration from Shell Scripts

### Phase 1: Core Functionality (Passive Monitoring)
- Implement Diplus API polling (15 second interval)
- Basic caching mechanism
- MQTT (via websocket) transmission (60 second interval)
- ABRP transmission (10 second interval)
- Home Assistant sensor discovery
- Read-only sensor data publishing
- Create shell scripts to build the entire solution
- Clean up our codebase and remove the old solution, update documentation/README

### Phase 2: Enhanced Features
- ABRP integration
- MQTT command subscription architecture
- Command handler framework

### Phase 3: Bidirectional Control
- Climate control commands (temperature, fan, mode)
- Door lock/unlock commands
- Engine start/stop commands
- Charging control commands
- Command validation and safety checks

### Phase 4: Production Ready
- Comprehensive error handling
- Performance optimization
- Command rate limiting and security

## Documentation Requirements

### Code Documentation
- **Package Comments**: Clear purpose and usage
- **Function Documentation**: Parameters, returns, examples
- **Type Documentation**: Struct field descriptions

### User Documentation
- **Installation Guide**: Step-by-step setup
- **Configuration Reference**: All options explained
- **Troubleshooting**: Common issues and solutions
- **API Reference**: Integration endpoints

## Development Workflow

### Git Workflow
- **Feature Branches**: `feature/component-name`
- **Commit Messages**: Conventional commits format
- **Pull Requests**: Required for all changes
- **Code Review**: Mandatory before merge

### CI/CD Pipeline
- **Build Verification**: Cross-platform compilation
- **Test Execution**: Unit and integration tests
- **Code Quality**: Linting and formatting checks
- **Security Scanning**: Dependency vulnerability checks
